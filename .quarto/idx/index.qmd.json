{"title":"pwpBench","markdown":{"yaml":{"title":"pwpBench","subtitle":"A python module to generate benchmark datasets for anomaly detection in context-dependent industrial relationships.","author":[{"name":"Mazen Alamir","affiliation":"CNRS, University of Grenoble Alpes","homepage":"https://www.mazenalamir.fr"}],"date":"October 25, 2025","keywords":["anomaly detection","Multivariate Polynomial","Identification of Invariants","Python"]},"headingText":"Creating instances of parametric anomalies.","containsRefs":false,"markdown":"\n\n---\n`pwpBench` is a python package that helps generating flexibly-defined datasets representing **context-dependent** industrial-like multivariate polynomial relationships. The dataset can be used in the validation and the evaluation of anomaly detection algorithms in Machine Learning. \n\n\n::: {.callout-tip}\n\nWhile anomalies can be introduced using standard drift or relative bias, the `pwpBench`, beside the creation of context dependent relationships, enables, through one of its exported methods, to create **parameteric-like anomalies** that represent bias affecting the coefficients of the underlying relationships.\n\nSuch process makes the anomaly detection benchmark closer to the industrial case where the anomalies are, at least very frequently, induced by shifts in the physical parameters of the equipment.\n\nMoreover, thanks to the context-based representation, it is possible to introduce anomalies that appears only in a specific context.\n:::\n\n# Installation \n```default\npip install pwp-bench\n```\n\n# Problem Statement {#pb-statement}\n\nOur objective is to define a context-dependent nonlinear relationship of the form:\n\n$$\ny = f_i(x) \\quad \\text{if}\\quad g(x)\\in [\\ell_i, u_i)\\quad i\\in \\{1,\\dots,n_r\\}\n$${#eq-defdey}\n\nwhere the intervals $[\\ell_i, u_i)$ define a partition of the set of possible values of the so-called context variable $z=g(x)\\in \\mathbb R$ when the features vector $x$ spans the hypercube $[x_\\text{min}, x_\\text{max}]\\subset \\mathbb R^{n_x}$.\n\nThe dimension of the features variable $x$ can be chosen by the user as well as the number of regions $n_r\\in \\mathbb N$ involved in the piece-wise degined relationship @eq-defdey. \n\nThe `pwpBench` module uses multi-variate polynomial to define all the maps invoved in @eq-defdey, namely $f_i$ for $i=1,\\dots,n_r$ and $g$ defining the context indicator $z$. Therefore, let us first of all precisely define what is a multivariate polynomial relationship.\n\n# Multi-variate polynomials {#sec-polynomial}\nA multi-variate polynomial  $P(x)$  in the vector of arguments $x\\in \\mathbb R^n$ takes the following form:\n\n$$\nP(x)=\\sum_{i=1}^{n_c}c_i \\phi_i(x)\\quad \\text{where}\\quad \\phi_i(x)=\\prod_{j=1}^{n}x_j^{p_{ij}}\n$${#eq-defdeP}\n\nNotice that $n_c$ is the number of multi-variate monomials involved in the definition of the polynomial $P(x)$  and $c_i$ is the weight of the $i$-th monomial.\n    \n\n::: {.callout-tip}\n# Arguments of definition of a multivariate polynomial\nBased on the above definition of $P(x)$, it comes out that a polynomial is defined by two arguments: \n\n1. **The matrix of powers** \n    $$\\texttt{powers}=\\Bigl[p_{ij}\\Bigr]_{(i,j)\\in \\{1,\\dots,n_c\\}\\times \\{1,\\dots,n\\}} \\in \\mathbb R^{n_c\\times n}$$\n\n2. **The vector of coefficients** $$c\\in \\mathbb R^{n_c}$$\n:::\n\nThe `pwpBench` module extensively uses this definition in order to build the piece-wise polynomial relationship as well as the boundaries of the domains that define the context. \n\n## Instantiation of a polynomial {#declaration}\n\nDeclaring a multivariate polynomial is done by creating an instance of the class `Pol`that is defined in the `optipoly` module[^1]. For instance, consider the following polynomial in three variables:\n\n$$\nP(x) = x_1x_3^2+2x_2^3\n$${#eq-examplePx}\n\nAn instance of the class `Pol` that represents this polynomial can be created via the following script:\n\n```python \nfrom optipoly import Pol\n\n# Define the matrix of powers and c.\n \npowers = [[1, 0, 2], [0,3,0]] \ncoefs = [1.0, 2.0]            \n\n# Create an instance of the class.\n\npol = Pol(powers, coefs)      \n```\n\n## Evaluation of the polynomial {#evaluation}\n\nThe following script computes the values of the polynomial at the arguments defined by the lines of the following matrix $X$:\n\n$$X:= \\begin{bmatrix} \n1&1&1\\cr -1&2&3\\cr 0&1&0\n\\end{bmatrix}$$\nwhich means that the polynomial is evaluated at the arguments:\n$$\\begin{bmatrix} \n1\\cr 1\\cr 1\n\\end{bmatrix}\\ ,\\  \\begin{bmatrix} \n-1\\cr 2\\cr 3\n\\end{bmatrix}\\ ,\\  \\begin{bmatrix} \n0\\cr 1\\cr 0\n\\end{bmatrix}$$\n\n```python \nX = [[1,1,1], [-1,2,3], [0,1,0]]\npol.eval(X)\n\n>> array([3., 7., 2.])\n```\n\nWith the previous reminder, we are now ready to discuss the main (and sole!) class of the `pwpBench` class, namely the `Problem` class.\n\n# The `Problem` class {#problem-class}\n\nLet us successively present the instantiation function, the attributes and the methods exported by the `Problem` class of the `pwpBench` module \n\n## Instantiation arguments {#sec-instantiation}\nThe table below describes the input arguments used to create an instance of the `Problem` class.\n\n:::{.tbl-caption}\n| **Parameter**     | **Description**      | **Default**|\n|---|---------------|----:|\n| `nx` | The number of features. | --|\n| `rho`| The size of the hyper-cube of the features domain. | -- |\n| `degrees`| The vector of degrees of the polynomials for the different contexts. Notice that the length of this variable determines the number of different contexts present in the data. | -- |\n| `nModes_max`| The maximum number of monomials[^3] involved in the polynomial relationship in any sub-domain. The effectively used number of monomials is then generated randomly to be lower or equal to this parameter. | -- |\n| `deg_boundary`| The degree of the multivariate polynomial that defines the boundary function $g$ used in @eq-defdey. | -- |\n| `nModes_boundary_max`| The upper bound on the maximum number of monomials used in the polynomial `g` used in @eq-defdey. | -- |\n\n\nTable: Arguments used in the creation of an instance of the `Problem` class.\n:::\n\nOnce these parameters are provided to the `__init__` instantiation function, corresponding attributes are created for the insance of the class `Problem` which are listed below: \n\n## Instances-related attributes {#sec-attributes}\n\nThe following list of attributes are created for an instance of the class `Problem`:\n\n:::{.tbl-caption}\n| **Parameter**     | **Description**      | **Default**|\n|---|---------------|----:|\n| `nx`| The number of features. | --|\n| `xmin`| Vector of lower bounds for $x$ as defined by `rho`. | --|\n| `xmax`| Vector of upper bounds for $x$ as defined by `rho`. | --|\n| `zmin`| Vector of lower bounds for $g$. This value is computed using the `solve` method of the `optipoly` module.| --|\n| `zmax`| Vector of upper bounds for $g$. This value is computed using the `solve` method of the `optipoly` module.| --|\n| `zdiv`| The values that define the  boundaries of the different context-related regions. More precisely, the first interval is defined by $(-\\infty,\\texttt{zdiv[0]})$, the second inteval is $(\\texttt{zdiv[0], zdiv[1]})$ and so on while the last interal is defined by $(\\texttt{zdiv[-1]}, +\\infty)$| --|\n| `qz`| A function such that `qz(g(x))` provides the index of the region to which belongs the  features vector $x$. | --|\n| `pols`| The list of polynomials of the different regions. Each member of the list is an instance of the class `Pol` mentioned above. For instance, to access to the matrix of power of the polynomials that holds in the region of index $i$, the variable `pols[i].powers` should be used. The same holds for the vector of coefficients of the same polynomial, namely `pols[i].coefs`| --|\n| `nSubModels`| The number of context dependent regions. This is simply the length of the vector of `degrees` provided in the instantiation call (see @sec-polynomial).| --|\n| `deg_boundary`| The degree of the polynomial $g$ defining the boundary of the contexts regions. | --|\n\n\nTable: Attributes of an instance of the `Problem` class.\n:::\n\n## Exported Methods {#sec-methods}\n\nIn this section, the methods exported by the class `Problem` are listed and described. There are three useful methods exported by the class `Problem`: \n\n### 1) The `generate_data` method {#sec-generate_data}\n\nThis method generates the triplet `(X,y,idz)` representing respectively, the features matrix, the label vecor and the index of the context. The resulting dataset can then be used to create detuned version that corresponds to the user's will. \n\nThis method takes the following input arguments: \n\n**INPUT ARGUMENTS for the `generate_data` method**\n\n- `nSamples`: the number of samples to be generated.\n- `stratified`: a boolean to ask for a stratified version of the data or not.\n- `cv`: the number of inner sub-intervals to create from a given context subset of data\n- `plot`: a boolean to ask for a plotting of the dataset or not.\n\n**RETURNED RESULT from the `generate_data` method**\n\n- `X`: the Features matrix.\n- `y`: the label vector. \n- `idz`: the context indicator.\n- `fig`: the `plotly` fig if `plot`is set to true. This plot shows the evolution of the label `y`vs the sample number. \n\n### 2) The `plot_regions` method {#sec-plot_regions}\n\nThis method produces a 2D context-shaded representation of the data in order to examine the shape of the boundaries between context-determines regions in the dataset (see the example below). \n\nThis method is mainly used as an illustrative option. \n\n**INPUT ARGUMENTS for the `plot_regions` method**\n\n- `X`: the features matrix produced by `generate_data` method (see above).\n- `idz`: The context label as returned by the `generate_data` method (see above).\n- `col1`, `col2`: The two columns for the 2D representation.\n\n\n**RETURNED RESULT from the `plot_regions` method**\n\nA plotly figure showing the 2S colored regions in the coordinates defined by the input arguments `col1` and `col2`. \n\n### 3) The `create_working_dataframe` method {#sec-create_working_df}\n\nThis method takes a features matrix $X$ (that can be created through the `generate_data` method for instance and hence potentially stratified) and introduce parameteric anomaly that cover a part of the dataframe that is determined by the `test_size` input arguments. More precisely: \n\n\n**INPUT ARGUMENTS for the `create_working_dataframe` method**\n\n- `X`           : The matrix of features.\n- `i_anomaly`   : The index of context to be detuned. \n- `rel_bias`    : The standard deviation (relative to nominal) of the bias on the parameters \n                of the polynomials at the context indexed by `i_anomaly`.\n- `test_size`   : The portion of the detuned second part of the dataset. \n\n**RETURNED RESULY from the `create_working_dataframe` method**\n\n- `df`          : A dataframe containing nominal and detuned part (features, label, context)\n- `res`         : The residual profile should the relationship be perfectly known. Namely the absolute error between the detuned label and the label that would be prediced by the exact polynomial relationships.\n\nThe following schematic show the flow of use of the exported methods. \n\n![](images/overview_pwpBench.png)\n\n# Example {#sec-example}\n\n## Generating and visualizing data \n\nLet us see how context-dependent data can be created and visualized. Here we use `nx=2` for the sake of getting interesting visualization of the different context-dependent regions.\n\n```python \nfrom pwpBench import Problem\nfrom pwpBench import plot_regions\n\n# Define the argument of call for the instance creation\n\nargs = {\n    'nx' : 2,\n    'rho' : 1.5,\n    'degrees' : [1, 2, 3, 3],\n    'nModes_max' : 5,\n    'deg_boundary' : 2,\n    'nModes_boundary_max' : 10\n}\n\n# Create the instance \n\npb = Problem(**args)\n\n# call the instance generate_data method\n\nX, y, idz, fig = pb.generate_data(nSamples=50000, \n                    stratified=True, cv=4, plot=True)\n\n# show the plots if any \nif fig:\n    fig.show()\n\nfig_regions = plot_regions(X, idz, 0,1)\nfig_regions.show()\n```\n\nThis script prodcues the following results[^2]: \n\n![](images/fig.png)\n![](images/fig_regions.png)\n\nOther possibilities that might be obtained using repetitive execution of the previous script:\n\n![](images/others.png)\n\n## Context-dependent parametric anomalies\n\nThis script shows an example of generating first a triplet (`X`, `y`, `idz`) using the `generate_data` method from which the feautres matrix `X`is then used to define the detuned working dataset involving a nominal part followed by a detuned part. \n\n```python\nimport numpy as np\nimport pandas as pd \nfrom copy import deepcopy\nfrom optipoly import Pol \nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go \n\nargs = {\n    'nx' : 2,\n    'rho' : 1.5,\n    'degrees' : [1, 2, 3, 3],\n    'nModes_max' : 5,\n    'deg_boundary' : 2,\n    'nModes_boundary_max' : 10\n}\n\npb = Problem(**args)\n\nX, y, idz, fig = pb.generate_data(nSamples=10000, stratified=True, cv=4, plot=True)\n\n\ni_anomaly=2\ndf_nominal, _ = pb.create_working_dataframe(X, i_anomaly=i_anomaly, rel_bias=0)\ndf_detuned, res = pb.create_working_dataframe(X, i_anomaly=i_anomaly, rel_bias=0.4)\n\nxs = np.array([i for i in range(len(df_nominal))])\nfig = make_subplots(rows=3, cols=1, x_title='Sample Index', shared_xaxes=True)\n\nfig.add_trace(go.Scatter(x=xs, y=df_nominal.idz, name='Context indicator'), row=1, col=1)\nfig.add_trace(go.Scatter(x=xs, y=df_detuned.y, name='y_detuned'), row=2, col=1)\nfig.add_trace(go.Scatter(x=xs, y=df_nominal.y, name='y_nominal'), row=2, col=1)\nfig.add_trace(go.Scatter(x=xs, y=res, name='residual on detuned'), row=3, col=1)\nfig.update_layout(\n    title='Introducing parameteric anomalies',\n    width=600,\n    height=600\n)\n```\n\n![](images/final_use.png)\n\nNotice how the context number 2 is detuned in the second half (`test_size=0.5`) of the data while kept intact in the first part. This represent a context-related detuned data that might simulate an anomaly that is apparent only in the context 1 of operation. Think about a default in the braking system of an automotive which becomes apparent only when the driver is braking.\n\n# Citing pwpBench {#citing}\n\nThe complete details of the publication will be updated as soon as possible. \n\n```bibtex\n@misc{pwpBench2025,\n      title={pwpBench: A Python package for the creation of benchmarks problems for anomaly detection in multi-context industrial data.}, \n      author={Mazen Alamir},\n      year={2025},\n      eprint={xxx},\n      archivePrefix={arXiv},\n      primaryClass={eess.SY},\n      url={http://arxiv.org/abs/xxx}, \n}\n```\n\n[^1]: see the documentation [here](https://mazenalamir.github.io/optipoly/).\n\n[^2]: Remember that the generation process involves random steps so that it is unlikely that you get the same data and figures. \n\n[^3]: This is precisely the parameter $n_c$ used in @eq-defdey.","srcMarkdownNoYaml":"\n\n---\n`pwpBench` is a python package that helps generating flexibly-defined datasets representing **context-dependent** industrial-like multivariate polynomial relationships. The dataset can be used in the validation and the evaluation of anomaly detection algorithms in Machine Learning. \n\n\n::: {.callout-tip}\n# Creating instances of parametric anomalies.\n\nWhile anomalies can be introduced using standard drift or relative bias, the `pwpBench`, beside the creation of context dependent relationships, enables, through one of its exported methods, to create **parameteric-like anomalies** that represent bias affecting the coefficients of the underlying relationships.\n\nSuch process makes the anomaly detection benchmark closer to the industrial case where the anomalies are, at least very frequently, induced by shifts in the physical parameters of the equipment.\n\nMoreover, thanks to the context-based representation, it is possible to introduce anomalies that appears only in a specific context.\n:::\n\n# Installation \n```default\npip install pwp-bench\n```\n\n# Problem Statement {#pb-statement}\n\nOur objective is to define a context-dependent nonlinear relationship of the form:\n\n$$\ny = f_i(x) \\quad \\text{if}\\quad g(x)\\in [\\ell_i, u_i)\\quad i\\in \\{1,\\dots,n_r\\}\n$${#eq-defdey}\n\nwhere the intervals $[\\ell_i, u_i)$ define a partition of the set of possible values of the so-called context variable $z=g(x)\\in \\mathbb R$ when the features vector $x$ spans the hypercube $[x_\\text{min}, x_\\text{max}]\\subset \\mathbb R^{n_x}$.\n\nThe dimension of the features variable $x$ can be chosen by the user as well as the number of regions $n_r\\in \\mathbb N$ involved in the piece-wise degined relationship @eq-defdey. \n\nThe `pwpBench` module uses multi-variate polynomial to define all the maps invoved in @eq-defdey, namely $f_i$ for $i=1,\\dots,n_r$ and $g$ defining the context indicator $z$. Therefore, let us first of all precisely define what is a multivariate polynomial relationship.\n\n# Multi-variate polynomials {#sec-polynomial}\nA multi-variate polynomial  $P(x)$  in the vector of arguments $x\\in \\mathbb R^n$ takes the following form:\n\n$$\nP(x)=\\sum_{i=1}^{n_c}c_i \\phi_i(x)\\quad \\text{where}\\quad \\phi_i(x)=\\prod_{j=1}^{n}x_j^{p_{ij}}\n$${#eq-defdeP}\n\nNotice that $n_c$ is the number of multi-variate monomials involved in the definition of the polynomial $P(x)$  and $c_i$ is the weight of the $i$-th monomial.\n    \n\n::: {.callout-tip}\n# Arguments of definition of a multivariate polynomial\nBased on the above definition of $P(x)$, it comes out that a polynomial is defined by two arguments: \n\n1. **The matrix of powers** \n    $$\\texttt{powers}=\\Bigl[p_{ij}\\Bigr]_{(i,j)\\in \\{1,\\dots,n_c\\}\\times \\{1,\\dots,n\\}} \\in \\mathbb R^{n_c\\times n}$$\n\n2. **The vector of coefficients** $$c\\in \\mathbb R^{n_c}$$\n:::\n\nThe `pwpBench` module extensively uses this definition in order to build the piece-wise polynomial relationship as well as the boundaries of the domains that define the context. \n\n## Instantiation of a polynomial {#declaration}\n\nDeclaring a multivariate polynomial is done by creating an instance of the class `Pol`that is defined in the `optipoly` module[^1]. For instance, consider the following polynomial in three variables:\n\n$$\nP(x) = x_1x_3^2+2x_2^3\n$${#eq-examplePx}\n\nAn instance of the class `Pol` that represents this polynomial can be created via the following script:\n\n```python \nfrom optipoly import Pol\n\n# Define the matrix of powers and c.\n \npowers = [[1, 0, 2], [0,3,0]] \ncoefs = [1.0, 2.0]            \n\n# Create an instance of the class.\n\npol = Pol(powers, coefs)      \n```\n\n## Evaluation of the polynomial {#evaluation}\n\nThe following script computes the values of the polynomial at the arguments defined by the lines of the following matrix $X$:\n\n$$X:= \\begin{bmatrix} \n1&1&1\\cr -1&2&3\\cr 0&1&0\n\\end{bmatrix}$$\nwhich means that the polynomial is evaluated at the arguments:\n$$\\begin{bmatrix} \n1\\cr 1\\cr 1\n\\end{bmatrix}\\ ,\\  \\begin{bmatrix} \n-1\\cr 2\\cr 3\n\\end{bmatrix}\\ ,\\  \\begin{bmatrix} \n0\\cr 1\\cr 0\n\\end{bmatrix}$$\n\n```python \nX = [[1,1,1], [-1,2,3], [0,1,0]]\npol.eval(X)\n\n>> array([3., 7., 2.])\n```\n\nWith the previous reminder, we are now ready to discuss the main (and sole!) class of the `pwpBench` class, namely the `Problem` class.\n\n# The `Problem` class {#problem-class}\n\nLet us successively present the instantiation function, the attributes and the methods exported by the `Problem` class of the `pwpBench` module \n\n## Instantiation arguments {#sec-instantiation}\nThe table below describes the input arguments used to create an instance of the `Problem` class.\n\n:::{.tbl-caption}\n| **Parameter**     | **Description**      | **Default**|\n|---|---------------|----:|\n| `nx` | The number of features. | --|\n| `rho`| The size of the hyper-cube of the features domain. | -- |\n| `degrees`| The vector of degrees of the polynomials for the different contexts. Notice that the length of this variable determines the number of different contexts present in the data. | -- |\n| `nModes_max`| The maximum number of monomials[^3] involved in the polynomial relationship in any sub-domain. The effectively used number of monomials is then generated randomly to be lower or equal to this parameter. | -- |\n| `deg_boundary`| The degree of the multivariate polynomial that defines the boundary function $g$ used in @eq-defdey. | -- |\n| `nModes_boundary_max`| The upper bound on the maximum number of monomials used in the polynomial `g` used in @eq-defdey. | -- |\n\n\nTable: Arguments used in the creation of an instance of the `Problem` class.\n:::\n\nOnce these parameters are provided to the `__init__` instantiation function, corresponding attributes are created for the insance of the class `Problem` which are listed below: \n\n## Instances-related attributes {#sec-attributes}\n\nThe following list of attributes are created for an instance of the class `Problem`:\n\n:::{.tbl-caption}\n| **Parameter**     | **Description**      | **Default**|\n|---|---------------|----:|\n| `nx`| The number of features. | --|\n| `xmin`| Vector of lower bounds for $x$ as defined by `rho`. | --|\n| `xmax`| Vector of upper bounds for $x$ as defined by `rho`. | --|\n| `zmin`| Vector of lower bounds for $g$. This value is computed using the `solve` method of the `optipoly` module.| --|\n| `zmax`| Vector of upper bounds for $g$. This value is computed using the `solve` method of the `optipoly` module.| --|\n| `zdiv`| The values that define the  boundaries of the different context-related regions. More precisely, the first interval is defined by $(-\\infty,\\texttt{zdiv[0]})$, the second inteval is $(\\texttt{zdiv[0], zdiv[1]})$ and so on while the last interal is defined by $(\\texttt{zdiv[-1]}, +\\infty)$| --|\n| `qz`| A function such that `qz(g(x))` provides the index of the region to which belongs the  features vector $x$. | --|\n| `pols`| The list of polynomials of the different regions. Each member of the list is an instance of the class `Pol` mentioned above. For instance, to access to the matrix of power of the polynomials that holds in the region of index $i$, the variable `pols[i].powers` should be used. The same holds for the vector of coefficients of the same polynomial, namely `pols[i].coefs`| --|\n| `nSubModels`| The number of context dependent regions. This is simply the length of the vector of `degrees` provided in the instantiation call (see @sec-polynomial).| --|\n| `deg_boundary`| The degree of the polynomial $g$ defining the boundary of the contexts regions. | --|\n\n\nTable: Attributes of an instance of the `Problem` class.\n:::\n\n## Exported Methods {#sec-methods}\n\nIn this section, the methods exported by the class `Problem` are listed and described. There are three useful methods exported by the class `Problem`: \n\n### 1) The `generate_data` method {#sec-generate_data}\n\nThis method generates the triplet `(X,y,idz)` representing respectively, the features matrix, the label vecor and the index of the context. The resulting dataset can then be used to create detuned version that corresponds to the user's will. \n\nThis method takes the following input arguments: \n\n**INPUT ARGUMENTS for the `generate_data` method**\n\n- `nSamples`: the number of samples to be generated.\n- `stratified`: a boolean to ask for a stratified version of the data or not.\n- `cv`: the number of inner sub-intervals to create from a given context subset of data\n- `plot`: a boolean to ask for a plotting of the dataset or not.\n\n**RETURNED RESULT from the `generate_data` method**\n\n- `X`: the Features matrix.\n- `y`: the label vector. \n- `idz`: the context indicator.\n- `fig`: the `plotly` fig if `plot`is set to true. This plot shows the evolution of the label `y`vs the sample number. \n\n### 2) The `plot_regions` method {#sec-plot_regions}\n\nThis method produces a 2D context-shaded representation of the data in order to examine the shape of the boundaries between context-determines regions in the dataset (see the example below). \n\nThis method is mainly used as an illustrative option. \n\n**INPUT ARGUMENTS for the `plot_regions` method**\n\n- `X`: the features matrix produced by `generate_data` method (see above).\n- `idz`: The context label as returned by the `generate_data` method (see above).\n- `col1`, `col2`: The two columns for the 2D representation.\n\n\n**RETURNED RESULT from the `plot_regions` method**\n\nA plotly figure showing the 2S colored regions in the coordinates defined by the input arguments `col1` and `col2`. \n\n### 3) The `create_working_dataframe` method {#sec-create_working_df}\n\nThis method takes a features matrix $X$ (that can be created through the `generate_data` method for instance and hence potentially stratified) and introduce parameteric anomaly that cover a part of the dataframe that is determined by the `test_size` input arguments. More precisely: \n\n\n**INPUT ARGUMENTS for the `create_working_dataframe` method**\n\n- `X`           : The matrix of features.\n- `i_anomaly`   : The index of context to be detuned. \n- `rel_bias`    : The standard deviation (relative to nominal) of the bias on the parameters \n                of the polynomials at the context indexed by `i_anomaly`.\n- `test_size`   : The portion of the detuned second part of the dataset. \n\n**RETURNED RESULY from the `create_working_dataframe` method**\n\n- `df`          : A dataframe containing nominal and detuned part (features, label, context)\n- `res`         : The residual profile should the relationship be perfectly known. Namely the absolute error between the detuned label and the label that would be prediced by the exact polynomial relationships.\n\nThe following schematic show the flow of use of the exported methods. \n\n![](images/overview_pwpBench.png)\n\n# Example {#sec-example}\n\n## Generating and visualizing data \n\nLet us see how context-dependent data can be created and visualized. Here we use `nx=2` for the sake of getting interesting visualization of the different context-dependent regions.\n\n```python \nfrom pwpBench import Problem\nfrom pwpBench import plot_regions\n\n# Define the argument of call for the instance creation\n\nargs = {\n    'nx' : 2,\n    'rho' : 1.5,\n    'degrees' : [1, 2, 3, 3],\n    'nModes_max' : 5,\n    'deg_boundary' : 2,\n    'nModes_boundary_max' : 10\n}\n\n# Create the instance \n\npb = Problem(**args)\n\n# call the instance generate_data method\n\nX, y, idz, fig = pb.generate_data(nSamples=50000, \n                    stratified=True, cv=4, plot=True)\n\n# show the plots if any \nif fig:\n    fig.show()\n\nfig_regions = plot_regions(X, idz, 0,1)\nfig_regions.show()\n```\n\nThis script prodcues the following results[^2]: \n\n![](images/fig.png)\n![](images/fig_regions.png)\n\nOther possibilities that might be obtained using repetitive execution of the previous script:\n\n![](images/others.png)\n\n## Context-dependent parametric anomalies\n\nThis script shows an example of generating first a triplet (`X`, `y`, `idz`) using the `generate_data` method from which the feautres matrix `X`is then used to define the detuned working dataset involving a nominal part followed by a detuned part. \n\n```python\nimport numpy as np\nimport pandas as pd \nfrom copy import deepcopy\nfrom optipoly import Pol \nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go \n\nargs = {\n    'nx' : 2,\n    'rho' : 1.5,\n    'degrees' : [1, 2, 3, 3],\n    'nModes_max' : 5,\n    'deg_boundary' : 2,\n    'nModes_boundary_max' : 10\n}\n\npb = Problem(**args)\n\nX, y, idz, fig = pb.generate_data(nSamples=10000, stratified=True, cv=4, plot=True)\n\n\ni_anomaly=2\ndf_nominal, _ = pb.create_working_dataframe(X, i_anomaly=i_anomaly, rel_bias=0)\ndf_detuned, res = pb.create_working_dataframe(X, i_anomaly=i_anomaly, rel_bias=0.4)\n\nxs = np.array([i for i in range(len(df_nominal))])\nfig = make_subplots(rows=3, cols=1, x_title='Sample Index', shared_xaxes=True)\n\nfig.add_trace(go.Scatter(x=xs, y=df_nominal.idz, name='Context indicator'), row=1, col=1)\nfig.add_trace(go.Scatter(x=xs, y=df_detuned.y, name='y_detuned'), row=2, col=1)\nfig.add_trace(go.Scatter(x=xs, y=df_nominal.y, name='y_nominal'), row=2, col=1)\nfig.add_trace(go.Scatter(x=xs, y=res, name='residual on detuned'), row=3, col=1)\nfig.update_layout(\n    title='Introducing parameteric anomalies',\n    width=600,\n    height=600\n)\n```\n\n![](images/final_use.png)\n\nNotice how the context number 2 is detuned in the second half (`test_size=0.5`) of the data while kept intact in the first part. This represent a context-related detuned data that might simulate an anomaly that is apparent only in the context 1 of operation. Think about a default in the braking system of an automotive which becomes apparent only when the driver is braking.\n\n# Citing pwpBench {#citing}\n\nThe complete details of the publication will be updated as soon as possible. \n\n```bibtex\n@misc{pwpBench2025,\n      title={pwpBench: A Python package for the creation of benchmarks problems for anomaly detection in multi-context industrial data.}, \n      author={Mazen Alamir},\n      year={2025},\n      eprint={xxx},\n      archivePrefix={arXiv},\n      primaryClass={eess.SY},\n      url={http://arxiv.org/abs/xxx}, \n}\n```\n\n[^1]: see the documentation [here](https://mazenalamir.github.io/optipoly/).\n\n[^2]: Remember that the generation process involves random steps so that it is unlikely that you get the same data and figures. \n\n[^3]: This is precisely the parameter $n_c$ used in @eq-defdey."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"self-contained":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.32","theme":"flatly","toc-location":"left","title":"pwpBench","subtitle":"A python module to generate benchmark datasets for anomaly detection in context-dependent industrial relationships.","author":[{"name":"Mazen Alamir","affiliation":"CNRS, University of Grenoble Alpes","homepage":"https://www.mazenalamir.fr"}],"date":"October 25, 2025","keywords":["anomaly detection","Multivariate Polynomial","Identification of Invariants","Python"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}